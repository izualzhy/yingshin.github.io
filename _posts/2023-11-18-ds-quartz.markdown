---
title: "DolphinScheduler-10: quartz"
date: 2023-11-18 13:10:51 
tags: dolphin
---
ä¹‹å‰è®²[å·¥ä½œæµçš„å¯åŠ¨](https://izualzhy.cn/ds-how-process-start)ï¼Œæºå¤´æ˜¯`t_ds_command`è¡¨ï¼Œè¿™ç¯‡ç¬”è®°è®²è®²è¯¥è¡¨æ•°æ®æ˜¯å¦‚ä½•å†™å…¥çš„ï¼Œä¹Ÿå°±æ˜¯ Crontab çš„ç”Ÿæ•ˆè¿‡ç¨‹ã€‚

## 1. quartz

ç®€å•çš„ crontab å®ç°æ–¹å¼å¾ˆå¤šï¼Œjava.util.Timerã€spring @Scheduledã€akka scheduler etc.ã€‚ quartz<sup>1</sup>ä¹Ÿæ˜¯ä¸€ä¸ªè°ƒåº¦æ¡†æ¶ï¼Œå¯ä»¥é›†æˆåœ¨ java ç¨‹åºé‡Œï¼Œå¥½å¤„æ˜¯æŒä¹…åŒ–å’Œåˆ†å¸ƒå¼ã€‚

æˆ‘è§‰å¾— quartz é‡Œæœ€é‡è¦çš„æ¦‚å¿µæœ‰ä¸‰ä¸ªï¼š

1. JobDetail: ç”¨æˆ·ç»§æ‰¿è¯¥åŸºç±»å®ç°è‡ªå·±çš„ä»»åŠ¡ç±»ï¼Œæ‰§è¡Œå…·ä½“ä»»åŠ¡
2. Trigger: ä»»åŠ¡è§¦å‘å™¨ï¼Œæ¯”å¦‚ä¸€æ¬¡æ€§è§¦å‘ã€Crontab è§¦å‘ç­‰
3. Scheduler: è°ƒåº¦å™¨ï¼Œæ¥æ”¶ JobDetailï¼ŒæŒ‰ç…§ Trigger è°ƒåº¦

`JobBuilderã€TiggerBuilderã€JobKeyã€TriggerKey`ç­‰éƒ½æ˜¯ä¼´ç”Ÿçš„åè¯ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š

![quartz](/assets/images/dolphin/dolphin/quartz-uml.png)

`Date scheduleJob(JobDetail jobDetail, Trigger trigger)`æ·»åŠ æ–°çš„ä½œä¸šåŠè§¦å‘å™¨ï¼Œæ–¹æ³•æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼š

1. `JobDetail`:  ä¿å­˜äº†jobå”¯ä¸€åã€ä»»åŠ¡ç±»ã€jobé¢å¤–å±æ€§ç­‰
2. `Trigger`: ä¿å­˜äº†triggerå”¯ä¸€åã€triggerç±»å‹ã€triggeræ—¶é—´ç­‰

ä»£ç ç¤ºä¾‹æ¯”è¾ƒç®€å•ï¼Œæˆ‘æ”¾åˆ°äº†Bigdata-Systems<sup>2</sup>

å®šä¹‰äº†ä¸¤ä¸ªä»»åŠ¡ï¼Œè¿›ç¨‹å¯åŠ¨åä¼šå¼€å§‹è°ƒåº¦ï¼š

```
2023-11-18 23:50:20.016 [DolphinScheduler_Worker-1] INFO  cn.izualzhy.QuartzJob - start taskName:quartz-job1 ...
2023-11-18 23:50:20.016 [DolphinScheduler_Worker-1] INFO  cn.izualzhy.QuartzJob - stop  taskName:quartz-job1 ...
2023-11-18 23:50:20.035 [DolphinScheduler_Worker-2] INFO  cn.izualzhy.QuartzJob - start taskName:quartz-job2 ...
2023-11-18 23:50:20.035 [DolphinScheduler_Worker-2] INFO  cn.izualzhy.QuartzJob - stop  taskName:quartz-job2 ...
```

## 2. æŒä¹…åŒ–ä¸åˆ†å¸ƒå¼

æŒä¹…åŒ–æ˜¯æˆ‘ä»¬åœ¨ç”Ÿäº§ç¯å¢ƒè¦è€ƒè™‘çš„ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œquartz é‡Œç›¸å…³çš„é…ç½®ï¼šorg.quartz.jobStore.classï¼Œå¯ä»¥æ˜¯`RAMJobStore`ï¼Œä¹Ÿå¯ä»¥æ˜¯`JobStoreTX LocalDataSourceJobStore`ï¼Œåè€…æ”¯æŒjobã€triggeræŒä¹…åŒ–åˆ°æ•°æ®åº“ã€‚

![quartz-db](/assets/images/dolphin/quartz-db.png)

ç”¨æˆ·å±‚é¢å…³æ³¨æ¯”è¾ƒå¤šçš„å‡ ä¸ªè¡¨ï¼š

1. QRTZ_TRIGGERS: åŸºç¡€ Trigger ä¿¡æ¯ï¼Œä¸Šæ¬¡è§¦å‘æ—¶é—´ã€ä¸‹æ¬¡è§¦å‘æ—¶é—´ã€**trigger çŠ¶æ€**ç­‰
2. QRTZ_XXX_TRIGGERS: å­˜å‚¨CronTriggerã€SimpleTriggerã€DailyTimeIntervalTriggerã€CalendarIntervalTriggerã€è‡ªå®šä¹‰Triggerç­‰ä¿¡æ¯
3. QRTZ_JOB_DETAILS: Jobåã€ä»»åŠ¡ç±»ã€ä»»åŠ¡é™„åŠ ä¿¡æ¯ç­‰

å¸¸è§çš„ trigger çŠ¶æ€æœ‰ï¼š


| çŠ¶æ€     | å«ä¹‰                                                                                                                                                                                                                                                                                               |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| WAITING  | the normal state of a trigger, waiting for its fire time to arrive and be acquired for firing by a scheduler.                                                                                                                                                                                      |
| PAUSED   | means that one of the scheduler.pauseXXX() methods was used. The trigger is not eligible for being fired until it is resumed.                                                                                                                                                                      |
| ACQUIRED | a scheduler node has identified this trigger as the next trigger it will fire - may still be waiting for its fire time to arrive. After it fires the trigger will be updated (per its repeat settings, if any) and placed back into the WAITING state (or be deleted if it does not repeat again). |
| BLOCKED  | the trigger is prevented from being fired because it relates to a StatefulJob that is already executing. When the statefuljob completes its execution, all triggers relating to that job will return to the WAITING state.                                                                         |

æŒä¹…åŒ–ç›¸å…³ä»£ç å®ç°å¯ä»¥å‚è€ƒ`JobStoreSupport::storeJobAndTrigger`

quartz åŒæ ·æ”¯æŒé›†ç¾¤æ¨¡å¼ï¼Œä¾‹å­<sup>2</sup>å¤šè¿›ç¨‹çš„æƒ…å†µä¸‹ï¼Œä»»åŠ¡åˆ°äº†å¯åŠ¨æ—¶é—´ï¼Œç”±ä¸”åªç”±å•ä¸ªè¿›ç¨‹å¯åŠ¨ã€‚

åˆ†å¸ƒå¼ç›¸å…³ä»£ç å®ç°å¯ä»¥å‚è€ƒ`QuartzSchedulerThread::run`ã€`JobStore::acquireNextTriggers`ï¼Œæ ¸å¿ƒå®ç°åœ¨:

```java
public abstract class DBSemaphore implements Semaphore, Constants,
    StdJDBCConstants, TablePrefixAware {
    public boolean obtainLock(Connection conn, String lockName) {
        // SELECT * FROM QRTZ_LOCKS WHERE SCHED_NAME = '?' AND LOCK_NAME = ? FOR UPDATE 
    }
}
```

ä½¿ç”¨äº†æ’ä»–é”ã€‚

## 3. dolphinåº”ç”¨

### 3.1. QuartzExecutorImpl

é¡µé¢ä¸Šå¯¹å®šæ—¶ç®¡ç†çš„æ“ä½œä¼šè°ƒç”¨åˆ°`class QuartzExecutorImpl`ï¼Œå…¶ä¸­`addJob`é‡Œè´Ÿè´£æ›´æ–°å·¥ä½œæµåŠå…¶å®šæ—¶ç®¡ç†:

```java
public class QuartzExecutorImpl implements QuartzExecutor {
    @Override
    public void addJob(Class<? extends Job> clazz, int projectId, final Schedule schedule) {
        String jobName = this.buildJobName(schedule.getId());
        String jobGroupName = this.buildJobGroupName(projectId);

        Map<String, Object> jobDataMap = this.buildDataMap(projectId, schedule);
  
        // ...
  
        lock.writeLock().lock();
        try {
            JobKey jobKey = new JobKey(jobName, jobGroupName);
            JobDetail jobDetail;
            //add a task (if this task already exists, return this task directly)
            if (scheduler.checkExists(jobKey)) {
                jobDetail = scheduler.getJobDetail(jobKey);
                jobDetail.getJobDataMap().putAll(jobDataMap);
            } else {
                jobDetail = newJob(clazz).withIdentity(jobKey).build();
                jobDetail.getJobDataMap().putAll(jobDataMap);
                scheduler.addJob(jobDetail, false, true);
            }

            TriggerKey triggerKey = new TriggerKey(jobName, jobGroupName);
            /*
             * Instructs the Scheduler that upon a mis-fire
             * situation, the CronTrigger wants to have it's
             * next-fire-time updated to the next time in the schedule after the
             * current time (taking into account any associated Calendar),
             * but it does not want to be fired now.
             */
            CronTrigger cronTrigger = newTrigger()
                    .withIdentity(triggerKey)
                    .startAt(startDate)
                    .endAt(endDate)
                    .withSchedule(
                            cronSchedule(cronExpression)
                                    .withMisfireHandlingInstructionDoNothing()
                                    .inTimeZone(DateUtils.getTimezone(timezoneId))
                    )
                    .forJob(jobDetail).build();

            if (scheduler.checkExists(triggerKey)) {
                // updateProcessInstance scheduler trigger when scheduler cycle changes
                CronTrigger oldCronTrigger = (CronTrigger) scheduler.getTrigger(triggerKey);
                String oldCronExpression = oldCronTrigger.getCronExpression();

                if (!StringUtils.equalsIgnoreCase(cronExpression, oldCronExpression)) {
                    // reschedule job trigger
                    scheduler.rescheduleJob(triggerKey, cronTrigger);
                }
            } else {
                scheduler.scheduleJob(cronTrigger);
            }
        ...
    }
```

æ ¸å¿ƒä»£ç éƒ½åœ¨ä¸Šé¢äº†ï¼Œæ³¨æ„å‡ ç‚¹ï¼š

1. ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç”¨æˆ·ä»»åŠ¡ç±»ï¼Œä¼ å…¥äº†`ProcessScheduleJob.class`
2. CronTrigger é‡ŒæŒ‡å®šäº†`startDate`ã€`endDate`ã€`withMisfireHandlingInstructionDoNothing`
3. jobName ä½¿ç”¨äº†`schedule.getId()`ï¼Œä¹Ÿå°±æ˜¯`t_ds_schedules.id`ï¼Œ**è¿™æ˜¯ dolphin è‡ªèº«çš„è¡¨å’Œ quartz è¡¨çš„å…³è”ç‚¹**

### 3.2. ProcessScheduleJob

`ProcessScheduleJob`ç»§æ‰¿è‡ª`QuartzJobBean`ï¼Œé‡è½½äº†`executeInternal`æ–¹æ³•ã€‚æˆ‘ä»¬åœ¨å·¥ä½œæµé‡Œçœ‹åˆ°çš„è°ƒåº¦æ—¶é—´ï¼Œå®é™…ä¸Šå°±æ˜¯ quartz é‡Œçš„`getScheduledFireTime`ã€‚

```java
public class ProcessScheduleJob extends QuartzJobBean {

    protected void executeInternal(JobExecutionContext context) {
        JobDataMap dataMap = context.getJobDetail().getJobDataMap();

        int projectId = dataMap.getInt(Constants.PROJECT_ID);
        int scheduleId = dataMap.getInt(Constants.SCHEDULE_ID);

        Date scheduledFireTime = context.getScheduledFireTime();

        Date fireTime = context.getFireTime();

        // query schedule
        Schedule schedule = processService.querySchedule(scheduleId);
        ...

        ProcessDefinition processDefinition = processService.findProcessDefinitionByCode(schedule.getProcessDefinitionCode());
        ...
        Command command = new Command();
        command.setScheduleTime(scheduledFireTime);
        ...

        processService.createCommand(command);
    }
}
```

## 4. misfire

ç¬¬ä¸‰èŠ‚é‡Œæåˆ°äº†`withMisfireHandlingInstructionDoNothing`ï¼Œå…ˆè¯´ä¸‹ misfire çš„èƒŒæ™¯ï¼š

crontab åˆ°äº†è§¦å‘çš„æ—¶é—´ç‚¹ï¼Œå¯èƒ½æ­£å¸¸æ‰§è¡Œï¼Œä¹Ÿå¯èƒ½ç”±äºæŸäº›åŸå› ä¸èƒ½æ‰§è¡Œï¼Œæ¯”å¦‚ schedule å…¨éƒ¨å®•æœºäº†ã€çº¿ç¨‹æ‰“æ»¡å¯¼è‡´å®é™…è°ƒåº¦æ¯”é¢„æœŸæ—¶é—´æ™šäº†å¾ˆä¹…ç­‰ã€‚

ä¸åŒåœºæ™¯å°±ä¼šæœ‰ä¸åŒçš„é€‰æ‹©ï¼š

1. ç¦»çº¿æ•°ä»“è°ƒåº¦ï¼šç”±äºå¿…é¡»è¦äº§å‡ºå½“å¤©çš„åˆ†åŒºï¼Œå› æ­¤éœ€è¦èƒ½å¤Ÿä¿è¯æ‰§è¡Œ
2. å®æ—¶æ•°ä»“æ„å»ºï¼šç”±äºè°ƒåº¦é¢‘ç‡é«˜ï¼Œå®¹é”™æ€§å¼ºï¼Œå› æ­¤å¯ä»¥è·³è¿‡æ‰§è¡Œ
3. ä¸šåŠ¡åœºæ™¯ï¼šä¸åŒåœºæ™¯ä¸‹éœ€æ±‚ä¸åŒï¼Œå¦‚æœå…è®¸ï¼Œè¦è€ƒè™‘â€œè´ªåƒè›‡â€çš„ç°è±¡

quartz é’ˆå¯¹ä¸Šè¿°éœ€æ±‚ï¼Œä½¿ç”¨äº† misfire çš„æ¦‚å¿µï¼ˆåˆ°è¾¾ crontab æ—¶é—´æ—¶å¯åŠ¨ä»»åŠ¡ç§°ä¸ºfireğŸš€ï¼Œæ²¡æœ‰åˆ™ç§°ä¸º misfireï¼‰

1. å¤šä¹…æ²¡æœ‰è§¦å‘ï¼Œåˆ™è®¤ä¸º misfireï¼Œé€šè¿‡ org.quartz.jobStore.misfireThreshold é…ç½®ã€‚
2. è§¦å‘åçš„è¡Œä¸ºï¼Œåœ¨ trigger é‡Œé…ç½®ï¼Œç§°ä¸º misfire ç­–ç•¥ã€‚ä¸åŒ trigger ç±»å‹å¯é…ç½®çš„ä¸åŒ

æ¯”å¦‚ CronTriggerï¼Œå¯ä»¥é…ç½®çš„ misfire ç­–ç•¥æœ‰ï¼š

```java
public class CronScheduleBuilder extends ScheduleBuilder<CronTrigger> {
    public CronScheduleBuilder withMisfireHandlingInstructionIgnoreMisfires() {
        misfireInstruction = Trigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY;
        return this;
    }

    public CronScheduleBuilder withMisfireHandlingInstructionDoNothing() {
        misfireInstruction = CronTrigger.MISFIRE_INSTRUCTION_DO_NOTHING;
        return this;
    }

    public CronScheduleBuilder withMisfireHandlingInstructionFireAndProceed() {
        misfireInstruction = CronTrigger.MISFIRE_INSTRUCTION_FIRE_ONCE_NOW;
        return this;
    }
}
```

å„ç­–ç•¥è¯´æ˜ï¼š


| misfire instruction                                                                               | ç­–ç•¥æ•ˆæœ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|---------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| withMisfireHandlingInstructionIgnoreMisfires<br />(MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY)     | ç«‹å³è¡¥å…¨<br />All misfired executions are immediately executed, then the trigger runs back on schedule.<br />Example scenario: the executions scheduled at 9 and 10 AM are executed immediately.<br />The next scheduled execution (at 11 AM) runs on time.                                                                                                                                                                                                                                                   |
| withMisfireHandlingInstructionDoNothing<br />(withMisfireHandlingInstructionDoNothing)            | ç«‹å³è¡¥å…¨æœ€æ—©çš„ä¸€æ¬¡<br />Immediately executes first misfired execution and discards other<br />(i.e. all misfired executions are merged together). <br />Then back to schedule. <br />No matter how many trigger executions were missed, only single immediate execution is performed.<br />Example scenario: the executions scheduled at 9 and 10 AM are merged and executed only once (in other words: the execution scheduled at 10 AM is discarded).<br />The next scheduled execution (at 11 AM) runs on time. |
| withMisfireHandlingInstructionFireAndProceed<br />(CronTrigger.MISFIRE_INSTRUCTION_FIRE_ONCE_NOW) | å¿½ç•¥æ‰€æœ‰<br />All misfired executions are discarded, the scheduler simply waits for next scheduled time.<br />Example scenario: the executions scheduled at 9 and 10 AM are discarded, so basically nothing happens.<br />The next scheduled execution (at 11 AM) runs on time.                                                                                                                                                                                                                               | 

å…¶ä»–ç±»å‹çš„ triggerï¼Œä¾‹å¦‚`class SimpleScheduleBuilder`ä¹Ÿéƒ½æœ‰è‡ªå·±çš„ misfire ç­–ç•¥<sup>4</sup>.

dolphin é‡Œé»˜è®¤çš„è¡Œä¸ºæ˜¯`CronScheduleBuilder.withMisfireHandlingInstructionDoNothing`.

## 5. æ¼è°ƒåº¦ï¼šmissed their scheduled fire-time  

ä½¿ç”¨ dolphin çš„åŒå­¦ï¼Œå¯¹è¿™ä¸ªæ—¥å¿—åº”è¯¥ä¸é™Œç”Ÿï¼š

```log
2023-11-19 22:14:54.049 [...] INFO ... - Handling 1 trigger(s) that missed their scheduled fire-time.
```

é’ˆå¯¹ç¬¬1èŠ‚çš„ä¾‹å­ï¼Œåšä»¥ä¸‹[æ”¹åŠ¨](https://github.com/izualzhy/Bigdata-Systems/commit/3f8a97ba5cda1c10b3bd0b02690f40f5b544881e)ï¼š

1. è°ƒåº¦çº¿ç¨‹ä¿®æ”¹ä¸º1ï¼šorg.quartz.threadPool.threadCount: 1    
2. ä»»åŠ¡æ‰§è¡Œæ—¶å¢åŠ  sleep 15s  

å•çº¿ç¨‹è°ƒåº¦æ‰§è¡Œï¼ŒåŒæ—¶é…ç½®äº†`org.quartz.jobStore.misfireThreshold: 3000`.è€Œ job-1 æ¯ 10s è°ƒåº¦ä¸€æ¬¡ï¼Œæ¯æ¬¡æ‰§è¡Œæ—¶é—´ 15sï¼Œå› æ­¤å°±ä¼šè§¦å‘ job-1 çš„ misfire ç­–ç•¥`withMisfireHandlingInstructionDoNothing`

| æ—¥å¿—æ—¶é—´     | æ—¥å¿—è¡Œä¸º                                                                             | fire-time | next-fire-time |
|----------|----------------------------------------------------------------------------------|-----------|----------------|
| 22:26:40 | æ‰§è¡Œjob-1                                                                          | 22:26:40  | 22:26:50       |
| 22:26:55 | æ‰§è¡Œjob-1å®Œæˆ<br />æ‰“å°æ—¥å¿—`Handling 1 trigger(s) that missed their scheduled fire-time` |
| 22:27:00 | æ‰§è¡Œjob-1                                                                          | 22:27:00  | 22:27:10       |
| 22:27:15 | æ‰§è¡Œjob-1å®Œæˆ<br />æ‰“å°æ—¥å¿—`Handling 1 trigger(s) that missed their scheduled fire-time` |

ä¹Ÿå°±æ˜¯ä¸­é—´åº”è¯¥æœ‰çš„ä¸€æ¬¡ trigger è¢« misfire äº†ï¼Œ**åœ¨çº¿ä¸Šç¯å¢ƒï¼Œå°±æ˜¯ä¸€æ¬¡æ¼è°ƒåº¦çš„caseï¼Œéœ€è¦é‡è§†**

### 5.1. æºç ç›¸å…³ï¼šrecoverMisfiredJobs

å†æ¬¡å›åˆ°è¿™ç¯‡ç¬”è®°é‡Œæåˆ°å¤šæ¬¡çš„`JobStore`: çº¿ç¨‹æ–¹æ³•`manage`é‡Œä¼šè°ƒç”¨`recoverMisfiredJobs`:

```java
public abstract class JobStoreSupport implements JobStore, Constants {
    public void run() {

        while (!shutdown) {
            RecoverMisfiredJobsResult recoverMisfiredJobsResult = manage();
            ...
            Thread.sleep(timeToSleep);
        }
    }
    
    protected RecoverMisfiredJobsResult recoverMisfiredJobs(
            Connection conn, boolean recovering)
            throws JobPersistenceException, SQLException {

        // If recovering, we want to handle all of the misfired
        // triggers right away.
        int maxMisfiresToHandleAtATime =
                (recovering) ? -1 : getMaxMisfiresToHandleAtATime();

        List<TriggerKey> misfiredTriggers = new LinkedList<TriggerKey>();
        long earliestNewTime = Long.MAX_VALUE;
        // We must still look for the MISFIRED state in case triggers were left 
        // in this state when upgrading to this version that does not support it. 
        boolean hasMoreMisfiredTriggers =
                getDelegate().hasMisfiredTriggersInState(
                        conn, STATE_WAITING, getMisfireTime(),
                        maxMisfiresToHandleAtATime, misfiredTriggers);

        if (hasMoreMisfiredTriggers) {
            getLog().info(
                    "Handling the first " + misfiredTriggers.size() +
                            " triggers that missed their scheduled fire-time.  " +
                            "More misfired triggers remain to be processed.");
        } else if (misfiredTriggers.size() > 0) {
            getLog().info(
                    "Handling " + misfiredTriggers.size() +
                            " trigger(s) that missed their scheduled fire-time.");
        } else {
            getLog().debug(
                    "Found 0 triggers that missed their scheduled fire-time.");
            return RecoverMisfiredJobsResult.NO_OP;
        }
        
        ...

    }
}
```

`recoverMisfiredJobs`æ–¹æ³•æ£€æµ‹æ˜¯å¦æœ‰æ¼è°ƒåº¦çš„ä»»åŠ¡ï¼Œå¦‚æœæœ‰ï¼Œå°±æ‰“å°ä¸Šè¿°æ—¥å¿—ã€‚æ£€æµ‹æ˜¯é€šè¿‡ SQL å®ç°çš„ï¼š

```sql
-- SELECT_HAS_MISFIRED_TRIGGERS_IN_STATE
SELECT TRIGGER_NAME, TRIGGER_GROUP FROM {0}TRIGGERS
WHERE SCHED_NAME = {1} AND NOT (MISFIRE_INSTR = -1)
  AND NEXT_FIRE_TIME < ? AND TRIGGER_STATE = ?
ORDER BY NEXT_FIRE_TIME ASC, PRIORITY DESC
-- {0} -> QRTZ_
-- {1} -> "DolphinScheduler"
-- ? = ('WAITING', getMisfireTime()) 
```

`getMisfireTime()`å³å½“å‰æ—¶é—´-misfireThresholdï¼Œä¸Šè¿°ä»£ç ç®€å•æ€»ç»“å°±æ˜¯ï¼š

**`NEXT_FIR_TIME`è¡¨ç¤ºä»»åŠ¡é¢„è®¡ä¸‹æ¬¡è°ƒåº¦çš„æ—¶é—´ï¼Œå¦‚æœæ—¶é—´å·²ç»è¿‡äº†`NEXT_FIRE_TIME`+thresholdï¼Œè€Œ trigger è¿˜å¤„äº WAITING çŠ¶æ€ï¼Œé‚£ä¹ˆå°±è®¤ä¸ºè¿™ä¸ª trigger misfire äº†**

è¿™ä¹Ÿæ˜¯ misfire æœ¬æ¥çš„å®šä¹‰ã€‚

### 5.2. å¦‚ä½•ç›‘æ§å’Œè§£å†³

åŸå› åˆ†ææ¸…æ¥šäº†ï¼Œå¦‚ä½•è§£å†³ï¼Ÿ

æˆ‘çš„ç»éªŒæ— å¤–ä¹æ˜¯ä»¥ä¸‹å‡ ç‚¹ï¼š    
1. å¤šè¿›ç¨‹æé«˜å¹¶å‘    
2. æé«˜ quartz è°ƒåº¦çº¿ç¨‹æé«˜å¹¶å‘  
3. æé«˜ quartz misfireThreshold é¿å…è§¦å‘   

å¦‚æœè¿˜æœ‰é—®é¢˜ï¼Œç”±äºç›¸å…³æ“ä½œå‡ ä¹å…¨éƒ¨é›†ä¸­åœ¨æ•°æ®åº“ï¼Œå°±éœ€è¦è€ƒè™‘æ•°æ®åº“çš„æ€§èƒ½äº†ï¼Œtrigger é‡çº§åœ¨å‡ ä¸‡çš„è¯ï¼Œæ•°æ®åº“ä¸€èˆ¬éƒ½ä¸ä¼šæˆä¸ºç“¶é¢ˆ  

è¿˜æœ‰ä¸€ç‚¹æ˜¯å¦‚ä½•ç›‘æ§ï¼Œè¿™æ˜¯è¿™ä¸¤å¹´å·¥ä½œæ¯”è¾ƒç—›çš„ç‚¹ï¼Œç”±äºç¼ºä¹åˆç†çš„æ™‹å‡è¯„ä»·/é¡¹ç›®å¤ç›˜åˆ¶åº¦ï¼Œå¤§å¤šæ•°äººé€‰æ‹©æ•‘ç«è€Œåšä¸åˆ°æå‰æ‰‘ç­é—®é¢˜ã€‚  

æˆ‘æƒ³åˆ°çš„æ–¹æ³•æ˜¯åœ¨æ—¥å¿—é‡Œè¾“å‡º**å·¥ä½œæµå®é™…fireæ—¶é—´ - å·¥ä½œæµé¢„æœŸfireçš„æ—¶é—´**ï¼Œå¦‚æœè¿™ä¸ªå€¼æ¥è¿‘ misfireThresholdï¼Œå°±éœ€è¦æå‰è¯„ä¼°æ€§èƒ½äº†ã€‚  

## 6. ä¸€å®šæ˜¯æ¼è°ƒåº¦ä¹ˆï¼Ÿ

æŒ‰ç…§ä¸Šé¢çš„æºç åˆ†æï¼Œå¦‚æœæ¼è°ƒåº¦äº†ï¼Œä¸€å®šä¼šæ‰“å°`missed their scheduled fire-time`çš„æ—¥å¿—ã€‚

é‚£ä¹ˆå¦‚æœæ‰“å°äº†è¯¥æ—¥å¿—ï¼Œå°±ä¸€å®šè¡¨ç¤ºæ¼è°ƒåº¦äº†ä¹ˆï¼Ÿå¦‚æœå¯ä»¥çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¥å¿—åº”è¯¥æ˜¯ P0 æ—¥å¿—ï¼Œå¯ä»¥å¸®æˆ‘ä»¬é¢„è­¦æ¼è°ƒåº¦çš„é—®é¢˜ã€‚

å¯æƒœç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œå½“æˆ‘ä»¬æ–°æ’å…¥ä¸€æ¡ trigger ï¼Œå¦‚æœæŒ‡å®šäº† startDateï¼Œä¾‹å¦‚ï¼š

```java
            trigger = TriggerBuilder.newTrigger()
                    .withIdentity(triggerName, TRIGGER_GROUP_NAME)
                    .withSchedule(cronScheduleBuilder)
                    .startAt(Date.from(
                            LocalDate.of(2023, 11, 1)
                                    .atStartOfDay(ZoneId.systemDefault()).toInstant()))
```

QRTZ_TRIGGERS è¡¨é‡Œçš„è®°å½•ï¼š

| SCHED_NAME       | TRIGGER_NAME | NEXT_FIRE_TIME | PREV_FIRE_TIME | START_TIME    | MISFIRE_INSTR | 
|------------------|--------------|----------------|----------------|---------------|---------------|
| DolphinScheduler | trigger-1    | 1698804000000  | -1             | 1698768000000 | 2             | 

ä¹Ÿå°±æ˜¯è¯´åˆå§‹åŒ–çš„`NEXT_FIRE_TIME`æ˜¯åŸºäº`startAt`çš„ï¼Œæ­¤æ—¶ä¹Ÿå°±ä¼šè§¦å‘ä¸€æ¬¡`missed their scheduled fire-time`çš„æ—¥å¿—äº†

## å‚è€ƒèµ„æ–™

1. [quartz introduction](https://github.com/quartz-scheduler/quartz/blob/main/docs/introduction.adoc)
2. [Bigdata-Systems quartz example](https://github.com/izualzhy/Bigdata-Systems/tree/c97bc4ff0621d3590b9542998372bb08a5f1902e/quartz)
3. [What does BLOCKED state mean for Quartz trigger](https://stackoverflow.com/questions/25736881/what-does-blocked-state-mean-for-quartz-trigger)   
4. [Quartz scheduler misfire instructions explained](https://nurkiewicz.com/2012/04/quartz-scheduler-misfire-instructions.html)
